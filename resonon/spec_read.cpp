#include <iostream>
#include <fstream>
#include <exception>
#include <string>
#include <iomanip>
#include <assert.h>
#include <cstdlib>
#include <chrono>
#include <ctime>
#include <windows.h>
#include <direct.h>

// explicitly linked dependencies
#include <boost/thread.hpp> // C:\Program Files\boost_1_55_0\boost
#include "resonon_imager_basler.h" // C:\Program Files\ResononAPI\include

// This is a multithreaded implementation of a spectrometer read function running 
// the spec_read.exe generated by this script will continually record dataubes from a 
// connected PikaL or Pika XC2 spectrometer and will save it to disk in the ./data directory 
// 
// Author : Jarod Boone

// Data Properties 
#define LINE_NUM 100
#define OUTFILE "spec_data"

// Imager Properties 
#define FRAMERATE 100.0 // Hz
#define INTEGRATION_TIME 7.0 // Milliseconds 
#define GAIN 0.0 // Db 
#define SPECTRAL_BIN 2 // ???

// set this macro to 1 to enable print statements 
// #define DEBUG 1

// set this macro to 1 to save the date in filename 
#define VERBOSE_FN 1

// deprecated
typedef time_t std::chrono::time_point<std::chrono::system_clock>;

// standard variables (per program instance) that we will expose to threads
// without overloading parameters 
std::string wavelength_str; 
int cubesize; 

// function to poll the state of an imager and print the results to 
// standard output call this only after the imager has been connected  
void poll_imager(Resonon::PikaBasler *imgr) { 
	char buffer1[32], buffer2[32]; 

	// determine imager metadata 
	imgr->get_imager_type(buffer1, 32);
	imgr->get_serial_number(buffer2, 32);

	// print imager metadata to the console 
	std::cout << "Imager Status:\n";
	std::cout << "--------------\n";
	std::cout << std::setw(18) << "Imager Type: " << buffer1 << "\n";
	std::cout << std::setw(18) << "Serial Number: " << buffer2 << "\n";
	std::cout << std::setw(18) << "Framerate: " << imgr->get_framerate();
	std::cout << " [min: " << imgr->get_min_framerate();
	std::cout << ", max: " << imgr->get_max_framerate() << "]" << "\n";
	std::cout << std::setw(18) << "Integration Time: " << imgr->get_integration_time();
	std::cout << " [min: " << imgr->get_min_integration_time();
	std::cout << ", max: " << imgr->get_max_integration_time() << "]" << "\n";
	std::cout << std::setw(18) << "Gain: " << imgr->get_gain();
	std::cout << " [min: " << imgr->get_min_gain();
	std::cout << ", max: " << imgr->get_max_gain() << "]" << "\n";
	std::cout << std::setw(18) << "Bands: " << imgr->get_band_count() << "\n";
	std::cout << std::setw(18) << "Samples: " << imgr->get_sample_count() << "\n";
}

// the writer thread that gets spawned once a data cube gets read 
void writer(unsigned short* data,SYSTEMTIME* tstamps,int count,Resonon::PikaBasler *imgr) {

	// start the writer, this function should be called with a unique data and 
	// tstamp address that has been dynamically allocated prior to the function call
	#ifdef DEBUG 
		std::cout << "spawned a writer" << std::endl; 
	#endif 

	try { 
		// move into the data directory in the E: drive to write files 
		_chdir("E:\\resonon_data");
	} catch (std::exception const &e) { 
		std::cerr << "Could not switch into E drive: " << e.what() << std::endl;
		exit(EXIT_FAILURE);
	}
	 
	// create the data filename verbose
	std::ostringstream filename_ss;

	#ifdef VERBOSE_FN
		filename_ss << "basler_data_" << tstamps[0].wYear << "_" << tstamps[0].wMonth \
			<< "_" << tstamps[0].wDay << "_read" << count << ".bil";
	#elif 
		filename_ss << "basler_data_" << count << ".bil";
	#endif

  	std::string filename = filename_ss.str();

	std::string header_filename = filename + ".hdr";
	std::ofstream outfile(header_filename.c_str());
	outfile << "interleave = bil\n";
	outfile << "data type = 12\n";
	outfile << "bit depth = 12\n";
	outfile << "lines = " << LINE_NUM << "\n";
	outfile << "framerate = " << FRAMERATE << "\n";
	outfile << "shutter = " << INTEGRATION_TIME << "\n";
	outfile << "gain = " << GAIN << "\n";
	outfile << "start time = " << tstamps[0].wHour << ":" << tstamps[0].wMinute \
		<< ":" << tstamps[0].wSecond << ":" << tstamps[0].wMilliseconds << "\n";
	outfile << "end time = " << tstamps[1].wHour << ":" << tstamps[1].wMinute \
		<< ":" << tstamps[1].wSecond << "." << tstamps[1].wMilliseconds << "\n";
	outfile << wavelength_str; 
	outfile.close();

	// write to the data file 
	std::ofstream cubefile;
	cubefile.open(filename.c_str(), std::ios::out | std::ios::binary);
	cubefile.write((const char*)data, cubesize * sizeof(unsigned short));
	cubefile.close();

	// clean that joan 
	std::free(data); 
	std::free(tstamps); 

	return; 
	
}

// main loops
int main() { 
	#ifdef DEBUG 
		std::cout << "Read loop starting..." << std::endl;
	#endif  

	// "imgr" variable will hold the Pika object that will take care of pretty
	// much everything for us. This program closely follows the reccomendations 
	// from the ResononAPI see http://docs.resonon.com/API/html/index.html
	Resonon::PikaBasler imgr;

	// connect to the imager via USB3, if this fails either the sensor isn't connected 
	// or we are screwed
	try { 
		imgr.connect(); 
	} catch (std::exception const &e) { 
		std::cerr << "Error connecting to Spectrometer: " << e.what() << std::endl;
		exit(EXIT_FAILURE);
	}

	#ifdef DEBUG 
		std::cout << "Sensor Connected Successfully!" << std::endl;
	#endif 

	// set imager specifications 
	imgr.set_framerate(FRAMERATE); 
	imgr.set_integration_time(INTEGRATION_TIME); 
	imgr.set_gain(GAIN);
	imgr.set_spectral_bin(SPECTRAL_BIN); // Full disclosure... not sure what this does 

	#ifdef DEBUG
		// print imager state to standard output
		poll_imager(&imgr);  
	#endif 

	// number of bands and number of samples make a single frame 
	int framesize = imgr.get_band_count() * imgr.get_sample_count();

	// sanity check 
	assert(framesize * sizeof(unsigned short) == imgr.get_frame_buffer_size_in_bytes());

	// a "cube" of data is a bunch of frames 
	cubesize = framesize * LINE_NUM; 

	// prepare to start reading 
	unsigned short *buffer; 
	SYSTEMTIME *tstamps; 
	imgr.start();

	// counter to write filename 
	int count = 0;

	// generate the wavelength string to write out headers	
	std::ostringstream wavelength_ss;
	wavelength_ss << "wavelength = {"; 
	wavelength_ss << std::setprecision(5); 

	// build the wavelegnth string from string stream
	int num_bands = imgr.get_band_count();
	for (int i = 0; i < num_bands - 1; i++) {
		wavelength_ss << imgr.get_wavelength_at_band(i) << ", ";
	}

	// last wavelength to string stream 
	wavelength_ss << imgr.get_wavelength_at_band(num_bands - 1) << "}\n";

	// export string stream to global variable 
	wavelength_str = wavelength_ss.str();

	// the primary read loop 
	for (;;) { 
		// allocate a new buffer 
		buffer = (unsigned short *) std::malloc(sizeof(unsigned short) * cubesize); 
		tstamps = (SYSTEMTIME *) std::malloc(sizeof(SYSTEMTIME) * 2);

		// really hope we don't run out of memory 
		if (!buffer) {
			 std::cerr << "Could not allocate enough space for data buffer" << std::endl; 
			 exit(EXIT_FAILURE); 
		}

		// also hope we don't run out of memory here 
		if (!tstamps) {
			 std::cerr << "Could not allocate enough space for time stamp buffer" << std::endl; 
			 exit(EXIT_FAILURE); 
		}

		try {
			// log the start time 
			GetSystemTime(&tstamps[0]); 

			// read a datacube into the buffer 
			for (int i = 0; i < LINE_NUM; i++) {
				imgr.get_frame(&buffer[i * framesize]);

				// #ifdef DEBUG 
				// 	std::cout << "Line " << i + 1 << " of " << LINE_NUM << std::endl;
				// #endif 
			}

			// log the stop time 
			GetSystemTime(&tstamps[1]); 
		} catch (std::exception const & e) { 
			std::cerr << "Error reading from Spectrometer: " << e.what() << std::endl;
			int trash; 
			std::cin >> trash; 
			exit(EXIT_FAILURE);
		}

		// std::cout << "read" << std::endl;
		// dispatch a writer thread with the data and timelogs 
		boost::thread wrt(writer, buffer, tstamps, count, &imgr);

		// we will not be cleaning this thread up 
		wrt.detach();

		// increment data
		count++; 
	}

	exit(1); 
}
